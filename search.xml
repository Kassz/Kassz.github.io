<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dfs和bfs题目选做]]></title>
    <url>%2F2019%2F05%2F19%2Fdfs%E5%92%8Cbfs%E9%A2%98%E7%9B%AE%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[Phillip and Trains(CodeForces - 585B) 题意：在一个$3*N(2&lt;=N&lt;=100)$的图形中，有一人的行走方式是先向右走，然后再选择向上、向下、不走这三种方式中的一种、然后图形中有若干车辆每过一个时间，向左行驶$2$个格子题解：每一个时间建立一个图形，根据图形的限制和行走方式bfs就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxtime=411;const int maxrow=4;const int maxcol=110;int vis[maxtime][maxrow][maxcol];char str[maxrow][maxcol];bool maze[maxtime][maxrow][maxcol];bool times[maxtime];int n=4,m,k;int sx,sy;struct node&#123; int time,x,y; node(int _time,int _x,int _y):time(_time),x(_x),y(_y)&#123;&#125; node&amp; operator=(const node&amp; tmp)&#123; time=tmp.time; x=tmp.x; y=tmp.y; return *this; &#125;&#125;;int dx[4]=&#123;-1,1,0&#125;,dy[4]=&#123;0,0,0&#125;;queue&lt;node&gt; q;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; while(!q.empty()) q.pop(); scanf("%d%d",&amp;m,&amp;k); //printf("%d %d\n",m,k); memset(vis,0,sizeof(vis)); memset(times,false,sizeof(times)); times[0]=true; for(int i=1;i&lt;=3;i++)&#123; scanf("%s",str[i]+1); for(int j=1;j&lt;=m;j++)&#123; if(str[i][j]=='.')&#123; maze[0][i][j]=false; &#125;else if(str[i][j]=='s')&#123; sx=i,sy=j; maze[0][i][j]=false; &#125;else&#123; maze[0][i][j]=true; &#125; &#125; &#125; vis[0][sx][sy]=1; bool isok=0; q.push(node(0,sx,sy)); while(!q.empty())&#123; node tmp=q.front(); q.pop(); if(tmp.y==m)&#123; isok=true; break; &#125; if(times[tmp.time+1]==false)&#123; for(int i=1;i&lt;=3;i++)&#123; for(int j=1;j&lt;=m-2;j++)&#123; maze[tmp.time+1][i][j]=maze[tmp.time][i][j+2]; &#125; maze[tmp.time+1][i][m-1]=false; maze[tmp.time+1][i][m]=false; &#125; times[tmp.time+1]=true; &#125; int kx=tmp.x,ky=tmp.y+1; if(!(kx&gt;0&amp;&amp;kx&lt;=3&amp;&amp;ky&gt;0&amp;&amp;ky&lt;=m&amp;&amp;!maze[tmp.time][kx][ky]))&#123; continue; &#125; for(int i=0;i&lt;3;i++)&#123; int nx=kx+dx[i],ny=ky+dy[i]; if(nx&gt;0&amp;&amp;nx&lt;=3&amp;&amp;ny&gt;0&amp;&amp;ny&lt;=m&amp;&amp;!maze[tmp.time][nx][ny]&amp;&amp;!maze[tmp.time+1][nx][ny]&amp;&amp;!vis[tmp.time+1][nx][ny])&#123; vis[tmp.time+1][nx][ny]=true; q.push(node(tmp.time+1,nx,ny)); &#125; &#125; &#125; if(isok) printf("YES\n"); else printf("NO\n"); &#125;&#125; Monkeys(HDU - 6178) 题意：有一颗数有$N(2&lt;=N&lt;=100000)$个节点,有$K(2&lt;=K&lt;=100000)$个猴子,问将$K$个猴子，放在树上节点中(每个节点只能放一个猴子)，每个猴子至少和一个猴子连通的，需要的最少边数。题解：此问题可以看成一个二分图匹配的问题，在树中猴子通过一条边两两匹配的最大数量，剩下没有匹配的猴子，随意连接一个猴子即可。最大匹配数量可以使用贪心做也可以使用树形DP做，树形DP的解法如下：$dp[u][0]$表示u为根的子树中，不使用u匹配的最大匹配数量。$dp[u][1]$表示u为根的子树中，使用u匹配的最大匹配数量。状态转移公式如下：$dp[u][0]=\sum\limits_{v\in{son(u)}}{max(dp[v][0],dp[v][1])}$$dp[u][1]=max(dp[u][0]-max(dp[v][0],dp[v][1])+dp[v][0]+1)(v\in{son(u)})$$son(u)$表示$u$的儿子节点。注意题目要用fread的读入挂，否则会超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct FastIO&#123; static const int S = 2*100; int wpos; char wbuf[S]; FastIO() : wpos(0) &#123;&#125; inline int xchar() &#123; static char buf[S]; static int len = 0, pos = 0; if (pos==len) pos = 0, len = fread(buf, 1, S, stdin); if (pos==len) exit(0); return buf[pos ++]; &#125; inline int xint() &#123; int s = 1, c = xchar(), x = 0; while(c&lt;=32) c = xchar(); if(c=='-') s = -1, c = xchar(); for(;'0'&lt;=c &amp;&amp; c&lt;='9';c=xchar()) x = x*10+c-'0'; return x * s; &#125; ~FastIO() &#123; if(wpos) fwrite(wbuf, 1, wpos, stdout), wpos = 0; &#125;&#125;io;const int maxn=100000+10;struct Edge&#123; int nxt,to;&#125;edge[2*maxn];int n,k,head[maxn],tot,vis[maxn];int dp[maxn][2];void addedge(int u,int v)&#123; edge[tot].nxt=head[u]; edge[tot].to=v; head[u]=tot++;&#125;void dfs(int u,int pre)&#123; int tmp=0; dp[u][0]=dp[u][1]=0; for(int i=head[u];i!=-1;i=edge[i].nxt)&#123; int v=edge[i].to; if(v==pre) continue; dfs(v,u); dp[u][0]+=max(dp[v][0],dp[v][1]); tmp+=max(dp[v][0],dp[v][1]); &#125; for(int i=head[u];i!=-1;i=edge[i].nxt)&#123; int v=edge[i].to; if(v==pre) continue; dp[u][1]=max(dp[u][1],tmp-max(dp[v][0],dp[v][1])+dp[v][0]+1); &#125;&#125;int main()&#123; int t; t=io.xint(); while(t--)&#123; tot=0; memset(head,-1,sizeof(head)); memset(vis,0,sizeof(vis)); n=io.xint(); k=io.xint(); for(int i=1;i&lt;=n-1;i++)&#123; int u; u=io.xint(); addedge(u,i+1); addedge(i+1,u); &#125; dfs(1,-1); int ans=max(dp[1][0],dp[1][1]); if(2*ans&gt;=k)&#123; if(k%2==1) printf("%d\n",k/2+1); else printf("%d\n", k/2); &#125;else&#123; printf("%d\n", ans+k-2*ans); &#125; &#125;&#125; Lucky Numbers(CodeForces - 95B) 题意：定义一种幸运数，只有$4$和$7$的数字，且$4$和$7$的个数要相同。给一个$N(1&lt;=N&lt;=10^{100000})$，问大于等于$N$的最小的幸运数是什么。题解：当$N$有奇数位的时候，直接输出$(N+1)/2$个$4$和$(N+1)/2$个$7$；当$N$有偶数位的时候，直接dfs,根据$4$和$7$的个数进行剪枝，如果找不到，输出$(N+2)/2$个$4$和$(N+2)/2$个$7$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int n,a[maxn],num[maxn],cnt;char str[maxn];bool dfs(int pos,bool limt,int num4,int num7)&#123; int down=limt?a[pos]:0; if(num4&gt;n/2||num7&gt;n/2) return false; if(pos==n)&#123; if(num4==num7&amp;&amp;num4+num7==n) return true; &#125; if(4&gt;=down)&#123; num[pos]=4; if(dfs(pos+1,limt&amp;&amp;a[pos]==4,num4+1,num7)) return true; &#125; if(7&gt;=down)&#123; num[pos]=7; if(dfs(pos+1,limt&amp;&amp;a[pos]==7,num4,num7+1)) return true; &#125; return false;&#125;int main()&#123; scanf("%s",str); n=strlen(str); for(int i=0;i&lt;n;i++)&#123; a[i]=str[i]-'0'; &#125; if(n%2==1)&#123; for(int i=1;i&lt;=(n+1)/2;i++) printf("4"); for(int i=1;i&lt;=(n+1)/2;i++) printf("7"); &#125;else&#123; if(dfs(0,true,0,0))&#123; for(int i=0;i&lt;n;i++)&#123; printf("%d",num[i]); &#125; cout&lt;&lt;endl; &#125;else&#123; for(int i=1;i&lt;=(n+2)/2;i++) printf("4"); for(int i=1;i&lt;=(n+2)/2;i++) printf("7"); cout&lt;&lt;endl; &#125; &#125; cout&lt;&lt;endl;&#125; Bitonix’ Patrol(CodeForces - 217D) 题意：在一个圆形的轨道上，有$n(2&lt;=n&lt;=1000)$个车站，相邻的车站间隔$m(1&lt;=m&lt;=120)$,有一个人驾驶火箭，火箭没有刹车，所以只会行驶到燃料耗尽才会停下来，可以顺时针行驶或者逆时针行驶，有$t(1&lt;=t&lt;=10000)$桶燃料，每桶燃料都有不超过$10^9$的燃料。有一特工希望摧毁一些燃料，使得剩余的燃料无论怎么使用，都不可能到达任何一个车站。问符合条件摧毁的集合数量有多少个，答案对$10^9+7$取余。题解：因为车站都是间隔$m$的，且是一个圆形的轨道，顺时针和逆时针行驶看成加或者减某一元素，我们可以将问题转化成，求子集无论怎么加减操作都不能能构成$m$的倍数，这些子集有多少个。所以我们只需要考虑一个数对$m$取余的情况，不需要关心这个数本身。当一个集合有$n$个元素的时候，它的非零子集有$2^n-1$个,例如集合${1,2,3}$,那么它的子集有${1,2,3}$、${1,2}$、${1,3}$、${2,3}$、${1}$、${2}$、${3}$只考虑加法，那么$1+2+3=6$、$1+2=3$、$1+3=4$、$2+3=5$、构造了一些新的数字，$1+2=3$和集合元素$3$相同，那么可以通过$1+2-3=0$构造出了一个$m$的倍数。所以这一集合不符合答案要求。如果一个集合的元素有7个，那么它的子集就有$2^7-1=127$个，$m$的最大取值是120，也就是$m$最多有${0}\thicksim{m-1}$，这120个余数，根据鸽巢原理必然会出现重复的数字，所以当元素个数大于等于$7$时，不符合答案要求。那么我们只需要讨论集合元素个数小于等于$6$的集合，当取了一个数$x$,那么我们就不能再取$x$了，因为通过$x-x=0$就能轻松的构成$m$的倍数。也不能取$m-i$，那么我们就只用考虑$1\thicksim{m/2}$的数了。因为使用二进制的位数表示$m$的余数。状态转移的方法：当取了$x$的时候，顺时针行驶相当于一个状态循环左移了$x$位，逆时针行驶相当于一个状态循环右移了$x$位。某一位是$0$则表示这个余数可以取。具体的转移方程看代码。(应为$m$最大是120可能需要120位的数取存，没有那么大的数，所以本文的代码使用了数组取模拟位运算)(注意本题也可以使用bitset加速位运算) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1010;#define mod 1000000007const int maxm=130;int num[maxm],vis[maxm],mm[8][maxm],a[8],modd[800];int n,m,t;int ans=0;void read(int &amp;x)&#123; int f=1;x=0;char s=getchar(); while(s&lt;'0'||s&gt;'9')&#123;if(s=='-')f=-1;s=getchar();&#125; while(s&gt;='0'&amp;&amp;s&lt;='9')&#123;x=x*10+s-'0';s=getchar();&#125; x*=f;&#125;void dfs(int dep,int pos)&#123; long long tmp=1; for(int i=0;i&lt;dep;i++) &#123; // printf("(%d,%d) ",a[i],num[a[i]]); tmp=(tmp*num[a[i]])%mod; &#125; // cout&lt;&lt;endl; ans=ans+tmp; if(ans&gt;=mod) ans-=mod; if(dep&lt;6)&#123; for(int i=pos;i&lt;=(m/2);i++)&#123; if(num[i]&amp;&amp;mm[dep][i]==0)&#123; if(dep&lt;5)&#123; for(int j=0;j&lt;m;j++) mm[dep+1][j]=mm[dep][j]; for(int j=0;j&lt;m;j++) &#123; mm[dep+1][modd[j+i]]|=mm[dep][j]; mm[dep+1][modd[j-i+m]]|=mm[dep][j]; &#125; mm[dep+1][i]=1; &#125; a[dep]=i; dfs(dep+1,i+1); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;t); for(int i=0;i&lt;t;i++)&#123; int tmp; read(tmp); tmp%=m; num[min(tmp,m-tmp)]++; &#125; for(int i=1;i&lt;=2*m;i++)&#123; modd[i]=i%m; &#125; mm[0][0]=1; dfs(0,1); printf("%d\n",ans);&#125; Sweets Game(CodeForces - 63E) 题意：有一个六边形的糖果盒，共有$19$个位置可以放糖果的位置，有两个人轮流取糖果，取糖果的方式为，以平行于六边形边的方式，取相邻的糖果，可以取$1$个或者多个糖果。谁最后不能取糖果，谁就输了。题解：$19$个位置，通过二进制的形式表示共用$2^{19}$种状态，定义$state$表示定义$dp[s]$表示状态$s$是必败态还是必胜态，$dp[s]=0$表示必败态，$dp[s]=1$表示必胜态。直接dfs,搜索可以走的每一步，根据博弈论的基础知识进行状态转移。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int maxs=(1&lt;&lt;19)+5;int dp[maxs],s;int a[10][10]=&#123; &#123;3,0,1,2&#125;, &#123;4,3,4,5,6&#125;, &#123;5,7,8,9,10,11&#125;, &#123;4,12,13,14,15&#125;, &#123;3,16,17,18&#125;&#125;;int b[10][10]=&#123; &#123;3,0,3,7&#125;, &#123;4,1,4,8,12&#125;, &#123;5,2,5,9,13,16&#125;, &#123;4,6,10,14,17&#125;, &#123;3,11,15,18&#125;,&#125;;int c[10][10]=&#123; &#123;3,2,6,11&#125;, &#123;4,1,5,10,15&#125;, &#123;5,0,4,9,14,18&#125;, &#123;4,3,8,13,17&#125;, &#123;3,7,12,16&#125;,&#125;;bool dfs(int ns)&#123; //printf("%d\n",ns); if(dp[ns]!=-1) return dp[ns]; for(int i=0;i&lt;5;i++)&#123; for(int j=1;j&lt;=a[i][0];j++)&#123; int tmp=0; for(int k=j;k&lt;=a[i][0];k++)&#123; tmp|=(1&lt;&lt;a[i][k]); if((ns&amp;tmp)==tmp) &#123; if(dfs(ns^tmp)==0) return dp[ns]=1; &#125; &#125; &#125; &#125; for(int i=0;i&lt;5;i++)&#123; for(int j=1;j&lt;=b[i][0];j++)&#123; int tmp=0; for(int k=j;k&lt;=b[i][0];k++)&#123; tmp|=(1&lt;&lt;b[i][k]); if((ns&amp;tmp)==tmp) &#123; if(dfs(ns^tmp)==0) return dp[ns]=1; &#125; &#125; &#125; &#125; for(int i=0;i&lt;5;i++)&#123; for(int j=1;j&lt;=c[i][0];j++)&#123; int tmp=0; for(int k=j;k&lt;=c[i][0];k++)&#123; tmp|=(1&lt;&lt;c[i][k]); if((ns&amp;tmp)==tmp) &#123; if(dfs(ns^tmp)==0) return dp[ns]=1; &#125; &#125; &#125; &#125; return dp[ns]=0;&#125;int main()&#123; memset(dp,-1,sizeof(dp)); int cnt=0; dp[0]=0; s=0; cnt=0; while(cnt&lt;19)&#123; char key; scanf("%c",&amp;key); if(key=='.')&#123; cnt++; //s|=(1&lt;&lt;cnt); &#125;else if(key=='O')&#123; cnt++; s|=(1&lt;&lt;(cnt-1)); &#125; &#125; if(!dfs(s))&#123; printf("Lillebror\n"); &#125;else&#123; printf("Karlsson\n"); &#125; //printf("%d\n",s);&#125; India and China Origins(HDU - 5652) 题意：给出一个$N*M(1&lt;=N,M&lt;=500)$的图形，每过一个时间有一个格子不能行走，问在那个时间开始，不能从最顶端走到最底端。题解:如果某一时间，可以从最顶端走到最底端，那么之前的时间也可以从最顶端走到最底端，如果某一时间不可以从最顶端走到最底端，那么之后的时间也不可以从最顶端走到最底端。根据这一性质，就可以二分时间，每次bfs或者dfs判断连通性就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=510;char str[maxn][maxn];int maze[maxn][maxn];int change[maxn][maxn];int vis[maxn][maxn];int n,m,q;int dx[4]=&#123;-1,1,0,0&#125;,dy[4]=&#123;0,0,-1,1&#125;;struct node&#123; int x,y;&#125;nod[maxn*maxn];bool dfs(int x,int y)&#123; vis[x][y]=1; if(x==n-1) return true; for(int i=0;i&lt;4;i++)&#123; int nx=x+dx[i],ny=y+dy[i]; if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;m&amp;&amp;change[nx][ny]==0&amp;&amp;!vis[nx][ny])&#123; if(dfs(nx,ny)) return true; &#125; &#125; return false;&#125;bool judge(int years)&#123; memcpy(change,maze,sizeof(maze)); for(int i=1;i&lt;=years;i++)&#123; change[nod[i].x][nod[i].y]=1; &#125; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;m;i++)&#123; if(!vis[0][i]&amp;&amp;change[0][i]==0)&#123; if(dfs(0,i)) return true; &#125; &#125; return false;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123; scanf("%s",str[i]); for(int j=0;j&lt;m;j++) maze[i][j]=str[i][j]-'0'; &#125; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;nod[i].x,&amp;nod[i].y); &#125; int l=0,r=q; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(judge(mid))&#123; l=mid+1; &#125;else&#123; r=mid; &#125; &#125; printf("%d\n",l); &#125;&#125;]]></content>
      <categories>
        <category>dfs</category>
        <category>bfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
</search>
